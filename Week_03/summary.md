# Lesson7 范型递归、树的递归
## 1. 递归的实现、特性、思维要点
树的面试题接发一般都是递归
● 节点的定义
● 重复性（自相似性）

左子树 < 根节点 < 右子树
前中序遍历 = 递归

● 递归的本质：循环，通过函数体来进行的循环。
● 例子
	○ 顺口溜
		■ 从前有座山
		■ 山里有座庙
		■ 庙里有个和尚讲故事
		■ 返回1
	○ 电影：盗梦空间
		■ 向下进入不同梦境中；向上又回到原来一层
		■ 通过声音同步回到上一层（参数）
		■ 每一层的环节和周围的人，都是一份拷贝、助教等几个人穿越不同层级的梦境。（发生、携带变化 -- 函数、全局变量）
● 最简单的递归：计算 n!
```
def Factorial(n):
if n <=1:
return 1
return n * Factorial(n-1)
```
● 递归模版 -- Python
	○ 代码模版
```
# Python
def recursion(level, param1, param2, ...): 
    # recursion terminator 
    if level > MAX_LEVEL: 
	   process_result 
	   return 
    # process logic in current level 
    process(level, data...) 
    # drill down 
    self.recursion(level + 1, p1, ...) 
    # reverse the current level status if needed
```
● 递归的步骤
	○ 递归终结条件
	○ 处理当前层逻辑
	○ 下探到下一层
	○ 清理当前层
● 递归的要点
	○ 不要人肉进行递归（最大误区）
	○ 找到最近最简方法，将其拆解成可重复解决的问题（最近重复子问题）
	○ 数学归纳法思维
		■ n=1, n=2 成立
		■ 当 n成立，n+1也成立


### 参考链接
● 递归代码模板

## 2. 实战题目解析：爬楼梯、括号生成
### 习题1：爬楼梯
● 找最近重复子问题
	○ F(1) = 1
	○ F(2) = 2
	○ F(3) = F(1) + F(2)
		■ 1，走2步
		■ 2，走1步
	○ 确定结果符合MECE原则（Mutually Exclusive Collectively Exhaustive）

### 习题2：括号生成
2n个格子，每个格子可以放左括号，或者右括号，
● 生成括号的函数
● 验证合法性
	○ 左括号：随时可以加，只要不超标
	○ 之前必须右左括号，左个数 > 右个数

### 习题3:验证二叉搜索树
● 特点：
	○ 左子树 < 根 < 右子树
	○ 中序遍历递增
● 判断中序遍历是否递增（在遍历中，判断当前节点、上一个节点是否递增）


### 实战题目
● 爬楼梯（阿里巴巴、腾讯、字节跳动在半年内面试常考）
● 括号生成 (字节跳动在半年内面试中考过)
● 翻转二叉树 (谷歌、字节跳动、Facebook 在半年内面试中考过)
● 验证二叉搜索树（亚马逊、微软、Facebook 在半年内面试中考过）
● 二叉树的最大深度（亚马逊、微软、字节跳动在半年内面试中考过）
● 二叉树的最小深度（Facebook、字节跳动、谷歌在半年内面试中考过）
● 二叉树的序列化与反序列化（Facebook、亚马逊在半年内面试常考）

### 课后作业
● 二叉树的最近公共祖先（Facebook 在半年内面试常考）
● 从前序与中序遍历序列构造二叉树（字节跳动、亚马逊、微软在半年内面试中考过）
● 组合（微软、亚马逊、谷歌在半年内面试中考过）
● 全排列（字节跳动在半年内面试常考）
● 全排列 II （亚马逊、字节跳动、Facebook 在半年内面试中考过）

# Lesson8- 分治、回溯
## 分治 Divede & Conquer
● 含义：把大问题，拆解成不同的子问题。
● 本质：找重复性、分解问题、组合子问题结果。

跟范型递归很像，区别：最后需要把结果组合，再返回。
### 关键问题：
● 怎么拆分子问题？
● 怎么merge subresult？
● 怎么对子结果进行质量控制、保证？

## 回溯 Backtracking

不断在每一层测试。
典型应用：八皇后、数独。

### 参考链接
● 分治代码模板
● 括号生成问题

### 习题1：Pow(x, n)
1. 暴力
return *=x

2. 分治
// 模版：(1) terminator (2) process (3)drill down, merge(subresult) (4) reverse states
```
X ^n --> 2^10 : 2^5  2^5 -> (2^2) * (2^2)  *2
pow(x, n):
subproblem: subresult = pow(x, n/2);
merge:
if n % 2 == 1{
result = subresult  *  subresult  * x;
} else (
result = subresult * subresult;
)
```

### 习题2：子集
● 每个格子：选、不选

实战题目
● Pow(x, n) （Facebook 在半年内面试常考）
● 子集（Facebook、字节跳动、亚马逊在半年内面试中考过）
参考链接
● 牛顿迭代法原理
● 牛顿迭代法代码

### 习题3：电话毫秒的字母组合
● 把电话号码的对应关系存到map里
● 不断drill down

### 习题4：N皇后
● 8皇后问题：n个皇后，使得彼此不能互相攻击
● 横竖撇捺

● 解法：回溯
	○ 每一层只能放一个皇后
	○ 检查和上面层的皇后，是否会互相攻击

### 实战题目
● 多数元素 （亚马逊、字节跳动、Facebook 在半年内面试中考过）
● 电话号码的字母组合（亚马逊在半年内面试常考）
● N 皇后（字节跳动、苹果、谷歌在半年内面试中考过）
